## 开始

`> python`进入python环境开始写程序

`>>> exit()`退出环境

`> python xxx.py`命令行执行python源文件

### pip命令

`pip list` 列出匹配管理的包

`pip install 包名` 安装

`pip uninstall 包名` 卸载

`pip -V`或`pip -version` 查看版本

### 初始笔记

1. `print()`函数中，参数end代表换行符，可以改变，如：`print(a, end=',')`，表示不换行，且用逗号替换
2. `print("{:.2f}".format(area))`表示area保留两位小数输出，`{}`为占位符，`format()`函数中的参数为需要格式化的对象
3. 数组相关：

```python
print("{}同学".format(name)) # 按格式输出完整名字
print("{}哥哥".format(name[0])) # 输出第一个字符
print("{}弟弟".format(name[1:])) # 从第二个字符开始输出直至末尾
```

4. 日期相关：

```python
from datetime import datetime
now = datetime.now() # 获得当前日期和时间信息
print(now)
now.strftime("%x") # 输出其中的日期部分
now.strftime("%X") # 输出其中的时间部分
```

## 实例解析

```python
TempStr = input("请输入带有符号的温度值：")
if TempStr[-1] in ['F','f']:
    C = (eval(TempStr[0:-1]) - 32) / 1.8
    print("转换后的温度是{:.2f}C".format(C))
elif TempStr[-1] in ['C','c']:
    F = 1.8 * eval(TempStr[0:-1]) + 32
    print("转换后的温度是{:.2f}F".format(F))
else:
    print("输入格式错误")
```

###  1 程序格式框架

Python采用“缩进”来表明程序的格式框架，表明代码之间的层次关系。建议采用4个空格的方式书写代码

注意：并不是所有代码都可以通过缩进包含其他代码，一般来说，判断、循环、函数、类等语法形式能够通过缩进包含一批代码，进而表达对应的语义，但是，如print()这样的简单语句不表达包含关系，不能使用缩进

### 2 注释

Python语言的两种注释方法：单行注释和多行注释，单行注释以#开头，多行注释以'''（三个单引号）开头和结尾

```python
# 单行注释

'''
多行注释1
多行注释2
'''
```

注释的用途：

1. 标明作者和版权信息
2. 解释代码原理或用途

程序中的注释一般采用单行注释，标记在关键代码同行。而对于一段关键代码，可以在其附近采用一个多行注释或多个单行注释给出代码的设计原理等信息

1. 辅助程序调试

### 3 命名与保留字

实例1.1中，`TempStr`是一个接收输入字符串的变量名字

Python允许采用大小写字母、数字、下划线和汉字等字符及其组合给变量命名，但名字的首字符不能是数字，中间不能出现空格，长度没有限制。不允许使用保留字作为变量名

Python 3 的33个保留字列表

| False    | def     | if       | raise  |
| -------- | ------- | -------- | ------ |
| None     | del     | import   | return |
| True     | elif    | in       | try    |
| and      | else    | is       | while  |
| as       | except  | lambda   | with   |
| assert   | finally | nonlocal | with   |
| break    | for     | not      | yield  |
| class    | from    | or       |        |
| continue | global  | pass     |        |

### 4 字符串

Python中，字符串是用两个引号" "或单引号' '括起来的零个或多个字符

字符串包括两种序号体系：正向递增序号和反向递减序号。如果字符串长度为L，正向递增以最左侧字符序号为0，向右依次递增，最右侧字符序号为L-1；反向递增以最右侧字符序号为-1，向左依次递减，做左侧字符序号为-L。这两种索引字符的方法可以同时使用。实例1.1中`TempStr[-1]`表示字符串TempStr的最后一个字符

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/25941432/1672370915917-f02eb8bd-68f7-4401-bb46-ad1d008eb03b.jpeg)

Python字符串也提供区间访问方式，采用[N: M]格式，表示字符串中从N到M（**不包含M**）的子字符串，其中，N和M为字符串的索引序号，可以混合使用正向递增序号和反向递减序号。实例1.1`TempStr[0: -1]`表示字符串TempStr变量第0个字符到最后一个字符但不包含最后一个字符的子串。（左闭右开）

### 5 赋值语句

同步赋值语句，可以同时给多个变量赋值，基本格式如下：

```
<变量1>, ..., <变量N> = <表达式1>, ..., <表达式N>
```

但应尽量避免将多个无关的单一赋值语句组合成同步赋值语句

### 6 input()函数

input()函数从控制台获得用户输入，无论用户在控制台输入什么内容，input()函数都以字符串类型返回结果

获得用户输入之前，可以包含一些提示性文字，使用方法如下：

```
<变量> = input(<提示性文字>)
```

### 7 分支语句

使用方式如下：

```python
if <条件1>:
    <语句块1>
elif <条件2>: 
    <语句块2>
...
else:
	<语句块N>
```

实例1.1中分支语句的表达式又保留字`in`组成，表示判断字符串TempStr的最后一个字符（TempStr[-1]）是否在一个由'F'或'f'组成的集合中。

### 8 eval()函数

eval(<字符串>)函数能够以Python表达式的方式解析并执行字符串，并将返回结果输出

简单来说，其作用是将输入的字符串变成Python语句，并执行该语句，实例1.1使用eval()函数将用户的部分输入由字符串转换成数字。

使用eval()函数处理字符串时需要注意合理使用，例如，若直接输入字符串"hello"，eval()函数会去掉两个引号，将其解释为一个变量。当输入字符串"'hello'"时，eval()函数会去掉外部的两个双引号，'hello'被解释为字符串。

若用户希望输入一个数字，并用程序对这个数字进行计算，可以采用以下方式：

```
value = eval(input("请输入要计算是数值："))
```

另外，Python支持+、-、*、/ 和 **（幂）5种基本算术运算操作

### 9 print()函数

当输出纯字符信息时，可以直接将待输出的内容传递给print()函数；当输出变量值时，需要采用格式化输出方式时，通过format()方法将待输出变量整理成期望输出的格式。

具体来说，print()函数用槽格式和format()方法将变量和字符串结合到一起输出。如`{:2f}`，大括号{}表示一个槽位置，这个括号中的内容由字符串后面紧跟的format()方法中的参数填充，:.2f表示输出数值取两位小数。

## 基本数据类型

### 1 数字类型及其操作

Python提供三种数字类型：整数、浮点数与复数

#### 整数类型

4种进制表示

| 进制种类 | 引导符号 | 描述           |
| -------- | -------- | -------------- |
| 十进制   | 无       | 默认情况       |
| 二进制   | 0b 或 0B | 0b101 或 0B101 |
| 八进制   | 0o 或 0O | 0o711 或 0O711 |
| 十六进制 | 0x 或 0X | 0xABC 或 0XABC |

#### 浮点数类型

Python要求所有浮点数必须带有小数部分，小数部分可以是0

两种标识方法：十进制表示与科学计数法表示

<a>e<b> = $a * 10^b$

需要注意的是：浮点数类型直接表示或科学计数法表示种的系数（<a>）最长可输出16个数字，浮点数运算结果中最长可输出17个数字，但计算机只能够提供15个数字的准确性

#### 复数类型

对于复数z，可以用z.real和z.imag分别获得它的实数部分和虚数部分

#### 内置的数值运算操作符

| 操作符 | 描述                               |
| ------ | ---------------------------------- |
| x + y  | 和                                 |
| x - y  | 差                                 |
| x * y  | 积                                 |
| x / y  | 商                                 |
| x // y | 整数商，即不大于x与y之商的最大整数 |
| x % y  | 取模                               |
| -x     | x的负值                            |
| +x     | x本身                              |
| x ** y | x的y次幂，即$x^y$                  |

操作符运算的结果可能改变数字类型，3种数字类型之间存在一种逐渐扩展的关系：整数 -> 浮点数 -> 复数，数字类型之间的相互运算所生成的结果的的类型的基本规则：

- 整数之间的运算，若数学意义上是小数，则结果为浮点数
- 整数之间的运算，若数学意义上是整数，则结果为整数
- 整数和浮点数混合运算，结果是浮点数
- 整数或浮点数与复数运算，结果是复数

#### 内置的数值运算函数

| 函数                       | 描述                           |
| -------------------------- | ------------------------------ |
| abs(x)                     | x的绝对值                      |
| divmod(x, y)               | 输出整数商与余数               |
| pow(x, y[, z])             | x的y次幂，可以选择对z取模      |
| round(x[, ndigits])        | 对x四舍五入，保留ndigits位小数 |
| max($x_1, x_2, ... , x_n$) | 返回最大值                     |
| min($x_1, x_2, ... , x_n$) | 返回最小值                     |

#### 内置的数字类型转换函数

| 函数              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| int(x)            | 将x转换为整数，x可以是浮点数或字符串                         |
| float(x)          | 返回浮点数x或者字符串x所对应的整数类型                       |
| complex(re[, im]) | 生成一个复数，实部为re，虚部为im，re可以是整数、浮点数或字符串，im可以是整数或浮点数但不能为字符串 |

### 2 math库的使用

#### 引用

**方法一**：`import math`

对math库种函数采用math.<b>()形式，如

```python
import math
math.ceil(10.2)
```

**方法二**：`from math import <函数名>`

如

```python
from math import floor
floor(10.2)
```

#### math库数学常数

| 常数     | 数学表示 | 描述              |
| -------- | -------- | ----------------- |
| math.pi  | \pi      | 圆周率            |
| math.e   | e        | 自然对数          |
| math.inf | \infty   | 正无穷大          |
| math.nan |          | 非浮点数标记，NaN |

#### math库的数值表示函数

| 函数                 | 数学表示 | 描述·                                        |
| -------------------- | -------- | -------------------------------------------- |
| math.fabs(x)         | \|x\|    | 返回x的绝对值                                |
| math.fsum([x,y,...]) | x+y+...  | 浮点数精确求和                               |
| math.factorial(x)    | x!       | 返回x的阶乘，若x是小数或负数，返回ValueError |
| math.gcd(a,b)        |          | 返回a和b的最大公约数                         |

#### math库的幂对数函数

| 函数                | 数学表示        | 描述                              |
| ------------------- | --------------- | --------------------------------- |
| math.pow(x,y)       | $x^y$           | 返回x的y次幂                      |
| math.exp(x)         | $e^x$           | 返回e的x次幂                      |
| math.sqrt(x)        | $\sqrt{x}$      | 返回x的平方根                     |
| math.log(x,[,base]) | $\log_{base} x$ | 返回x的对数值，只输入x时，返回lnx |

### 3 字符串类型及其操作

#### 字符串类型的表示

​	字符串是字符的序列表示，可以由一对单引号、双引号或三引号给构成。其中，单引号和双引号都可以表示单行字符串，两者作用相同。使用单引号时，双引号可以作为字符串的一部分；使用双引号时，单引号可以作为字符串的一部分。三引号可以表示单行或多行字符串

​	字符串以Unicode编码存储，因此，字符串的英文字符和中文字符都算作1个字符，如下：

```python
name = "Python语言程序设计"
print("name[0]: {}".format(name[0]))
print("name[0]: {}, name[7]: {},name[-1]: {}".format(name[0], name[7], name[-1]))
print("name[2:-4]: {}".format(name[2:-4]))
print("name[:6]: {}".format(name[:6]))
print("name[6:]: {}".format(name[6:]))
print("name[:]: {}".format(name[:]))
```

​		输出结果：

```python
name[0]: P
name[0]: P, name[7]: 言,name[-1]: 计
name[2:-4]: thon语言
name[:6]: Python
name[6:]: 语言程序设计
name[:]: Python语言程序设计
```

​	反斜杠字符（\）是一个特殊字符，在字符串中表示转义，即该字符与后面相邻的一个字符共同组成了新的含义，例如：

```python
print("Python\n语言\t程序\t设计")
```

​	输出结果：

```python
Python
语言    程序    设计
```

#### 基本的字符串操作符

| 操作符         | 描述                                      |
| -------------- | ----------------------------------------- |
| x+y            | 连接两个字符串x与y                        |
| x * n 或 n * x | 复制n次字符串x                            |
| x in s         | 如果x是s的子串，返回True，否则返回False   |
| str[i]         | 索引，返回第i个字符                       |
| str[N: M]      | 切片，返回索引第N到第M的子串，其中不包含M |

#### 内置的字符串处理函数

| 函数   | 描述                                                |
| ------ | --------------------------------------------------- |
| len(x) | 返回字符串x的长度，也可返回其他组合数据类型元素个数 |
| str(x) | 返回任意类型x所对应的字符串形式                     |
| chr(x) | 返回Unicode编码x对应的单字符                        |
| ord(x) | 返回单字符表示的Unicode编码                         |
| hex(x) | 返回整数x对应十六进制的小写形式字符串               |
| oct(x) | 返回整数x对应八进制数的小写形式字符串               |

#### 内置的字符串处理方法

| 方法                                 | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| str.lower()                          | 返回字符串str的副本，全部字符小写                            |
| str.upper()                          | 返回字符串str的副本，全部字符大写                            |
| str.islower()                        | 当str所有字符都是小写时，返回True，否则返回False             |
| str.isnumeric()                      | 当str所有字符都是数字时，返回True，否则返回False             |
| str.endswith(suffix[,start[,end]])   | str[start: end]以suffix结尾返回True，否则返回False           |
| str.startswith(prefix[,start[,end]]) | str[start: end]以prefix开始返回True，否则返回False           |
| str.split(sep = None, maxsplit = -1) | 返回一个列表，由str根据sep被分隔的部分构成，maxsplit为最大分割次数 |
| str.count(sub[,start[,end]])         | 返回str[start: end]中sub子串出现的次数                       |
| str.replace(old,new[,count])         | 返回字符串str的副本，所有old子串被替换为new，如果count给出，则前count次old出现被替换 |
| str.center(width[,fillchar])         | 返回长度为width的字符串，其中，str处于新字符串中心位置，两侧新增字符采用fillchar填充，当width小于字符串长度时，返回str |
| str.strip([chars])                   | 返回字符串str的副本，在其左侧和右侧去掉chars中列出的字符     |
| str.zfill(width)                     | 返回字符串str的副本，长度为width，不足部分在左侧添0，但如果str最左侧是“+”或者“-”，则从第二个字符左侧添加“0”，当width小于字符串长度时，返回str |

### 4 字符串类型的格式化

字符串通过format()方法进行格式化处理

#### format()方法的基本使用

基本使用格式：`<模板字符串>.format(<逗号分隔的参数>)`

其中，模板字符串由一系列槽（{}）组成，如果大括号中没有序号，则按照出现顺序替换。如果大括号中制定了使用参数的序号，按照序号对应参数替换，参数从0开始编号。调用format()方法会返回一个新的字符串。

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/25941432/1672754060109-be8bc020-62c0-4ef4-b849-29e67ca12ea1.jpeg)

若要在字符串中表示大括号，则采用`{{}}`表示`{}`

```python
print("{}: 计算机{}的CPU占用率为{}%".format("2016-12-31","Python",10))
s1 = "{}{}{}".format("圆周率是",3.1415926,"...")
s2 = "圆周率{{{1}{2}}}是{0}".format("无理数",3.1415926,"...") # 调用format()时解析大括号
print(s1)
print(s2)
```

输出结果：

```python
2016-12-31: 计算机Python的CPU占用率为10%
圆周率是3.1415926...
圆周率{3.1415926...}是无理数
```

#### format()方法的格式控制

format()方法中模板字符串的槽除了包括参数序号，还可以包括格式控制信息。

槽的内部样式：`{<参数序号>: <格式控制标记>}`

格式控制标记用来控制参数显示时的格式

| :        | <填充>             | <对齐>                     | <宽度>           | <,>                                  | <.精度>                              | <类型>                                 |
| -------- | ------------------ | -------------------------- | ---------------- | ------------------------------------ | ------------------------------------ | -------------------------------------- |
| 引导符号 | 用于填充的单个字符 | < 左对齐> 右对齐^ 居中对齐 | 槽的设定输出宽度 | 数字的千位分隔符，适用于整数和浮点数 | 浮点数小数部分或字符串的最大输出长度 | 整数类型 b,c,d,o,x,X浮点数类型 e,E,f,% |

对于<宽度>，如果该槽对应的format()参数长度比<宽度>设定值大，则使用参数实际长度；反之，则位数向北默认以空格字符补充

对于<填充>，指的是宽度内除了参数外的字符采用什么方式表示，默认采用空格，可以通过填充替换

```python
s = "Python"
print("{0:30}".format(s)) # 默认左对齐
print("{0:>30}".format(s)) # 右对齐
print("{0:*^30}".format(s)) # 居中且用*填充
print("{0:-^30}".format(s)) # 居中且用-填充
print("{0:3}".format(s))

print("{0:-^20,}".format(1234567890))
print("{0:-^20}".format(1234567890)) # 对比输出
print("{0:-^20,}".format(12345.67890))

print("{0:.2f}".format(12345.67890))
print("{0:H^20.3f}".format(12345.67890))
print("{0:.4}".format(s))

""" 
1. b表示输出整数的二进制方式
2. c表示输出整数对应的Unicode字符
3. d表示输出整数的十进制方式
4. o表示输出整数的八进制方式
5. x表示输出整数的小写十六进制方式
6. X表示输出整数的大写十六进制方式
"""
print("{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}".format(425)) 

"""  
1. e表示输出浮点数对应的小写字母e的指数形式
2. E表示输出浮点数对应的大写字母E的指数形式
3. f表示输出浮点数的标准浮点形式
4. %表示输出浮点数的百分形式
"""
print("{0:e},{0:E},{0:f},{0:%}".format(3.14))
```

输出结果：

```python
Python
                        Python
************Python************
------------Python------------
Python
---1,234,567,890----
-----1234567890-----
----12,345.6789-----
12345.68
HHHHH12345.679HHHHHH
Pyth
110101001,Ʃ,425,651,1a9,1A9
3.140000e+00,3.140000E+00,3.140000,314.000000%
```

## 程序的控制结构

### 1 分支结构

`if`语句语法格式

```python
if <条件>:
    <语句块>
```

`if-else`语句语法格式

```python
if <条件>:
    <语句块1>
else:
    <语句块2>
```

还有一种更简洁的方式，适合通过判断返回特定值，语法格式如下

```python
<表达式1> if <条件> else <表达式2>
```

其中表达式1或2一般是数字类型或字符串类型的一个值

`if-elif-else`语句语法格式

```python
if <条件>:
    <语句块1>
elif <条件2>：
	<语句块2>
...
else:
    <语句块N>
```

### 2 循环结构

#### 遍历循环：for语句

使用方法：

```python
for <循环变量> in <遍历结构>:
    <语句块>
```

for语句的循环执行次数是根据遍历结构中元素个数确定的，遍历循环可以理解为从遍历结构中逐一提取元素，放在循环变量中，对于所提取的每个元素执行一次语句块。

其中，遍历结构可以是字符串、文件、组合数据类型或range()函数等，常用的使用方式如下：

1. 循环N次

```python
for i in range(N):
    <语句块>
```

1. 遍历文件fi的每一行

```python
for line in fi:
    <语句块>
```

1. 遍历字符串s

```python
for c in s:
    <语句块>
```

1. 遍历列表ls

```python
for item in ls:
    <语句块>
```

for循环中扩展模式的使用方法：

```python
for <循环变量> in <遍历结构>:
    <语句块1>
else:
    <语句块2>
```

在这种扩展模式中，当for循环正常执行后，程序会继续执行else语句中的内容。else语句只在循环正常执行并结束后才执行。因此，可以在`<语句块2>`中放置判断循环执行情况的语句。

#### 无限循环：while语句

使用方法：

```python
while <条件>:
    <语句块>
```

扩展模式使用方法：

```python
while <条件>:
    <语句块1>
else:
    <语句块2>
```

性质同上for循环扩展模式

#### 循环保留字：break和continue

break用来跳出最内层循环，脱离该循环后程序从循环代码后执行。每个break语句只有能力跳出当前层次循环

```python
for s in "BIT":
    for i in range(10):
        print(s,end = "")
        if s == "I":
            break
```

执行结果：

```python
BBBBBBBBBBITTTTTTTTTT
```

continue用来结束当前当次循环，即不执行continue下面的语句，但不跳出当前循环

```python
for s in "PYTHON":
    if s == "T":
        continue
    print(s,end = "")
```

执行结果：

```python
PYHON
```

**二者区别**：continue语句只结束本次循环，而**不终止整个循环**的执行；而break语句则是**结束整个循环**过程，不再判断执行循环的条件是否成立。对于两种循环的**扩展模式**，使用continue对else没有影响，而使用break则不会执行else中的语句

### 3 random库的使用

random库解析

| 函数                           | 描述                                            |
| ------------------------------ | ----------------------------------------------- |
| seed(a = None)                 | 初始化随机数种子，默认值为当前系统时间          |
| random()                       | 生成一个[0.0, 1.0)之间的随机小数                |
| randint(a, b)                  | 生成一个[a, b]之间的整数                        |
| getrandbits(k)                 | 生成一个k比特长度的随机整数                     |
| randrange(start, stop[, step]) | 生成一个[start, stop)之间以step为步数的随机整数 |
| uniform(a, b)                  | 生成一个[a, b]之间的随机小数                    |
| choice(seq)                    | 从序列类型，例如列表中随即返回一个元素          |
| shuffle(seq)                   | 将序列类型中的元素随机排列，返回打乱后的序列    |
| sample(pop, k)                 | 从pop类型中随机选取k个元素，以列表类型返回      |

引用方法：`import random`或`from random import *`

生成随机数之前可以通过`seed()`函数制定随机数种子，随机数种子一般是一个整数，只要种子相同，每次生成的随机数序列也相同。

```python
seed(125)
print("{}.{}.{}".format(randint(1,10),randint(1,10),randint(1,10)))
print("{}.{}.{}".format(randint(1,10),randint(1,10),randint(1,10)))
seed(125)
print("{}.{}.{}".format(randint(1,10),randint(1,10),randint(1,10)))
```

运行结果：

```python
4.4.10
5.10.3
4.4.10
```

上述可以看出，在设定相同种子后，每次调用随机函数生成的随机数是相同的。

### 4 程序的异常处理

#### try-except语句

基本语法格式：

```python
try:
    <语句块1>
except <异常类型>:
    <语句块2>
```

#### 高级用法

多个except语句，语法格式如下：

```python
try:
    <语句块1>
except <异常类型1>:
    <语句块2>
...
except <异常类型N>:
	<语句块N+1>
except:
	<语句块N+2>
```

与`else`和`finally`配合使用，语法格式如下：

```python
try:
    <语句块1>
except <异常类型1>:
    <语句块2>
else:
    <语句块3>
finally:
    <语句块4>
```

当try中的语句块1正常执行结束且没有发生异常时，else中的语句块3执行，可以看作是对try语句块正常执行后的一种追加处理。finally语句块则不同，无论try中的语句块1是否发生异常，语句块4都会执行，可以将程序执行语句块1的一些收尾工作放在这里，例如关闭、打开文件等。

#### 异常处理的重新输入

```python
# 在程序中预设一个0~100之间的整数，让用户通过键盘输入所猜的数
import random
count = 1
num = random.randint(0,100)
while True:
    try:
        Num = eval(input("请输入一个0~100之间的数："))
        begin, end = 0, 100
        while num != Num:
            if Num > num:
                print("遗憾，太大了！")
                end = Num
                Num = eval(input("请输入一个{}~{}之间的数：".format(begin, end)))
            if Num < num:
                print("遗憾，太小了！")
                begin = Num
                Num = eval(input("请输入一个{}~{}之间的数：".format(begin, end)))
            count += 1
        print("预测{}次，你猜中了！".format(count))
        break
    except:
        print("输入内容必须为整数！")
```

在`try-except`结构之前加一个`while True:`即可，因为在触发异常时会将其捕获到然后处理掉。但是因为while无限循环的存在，又将重新回到原点重新输入内容。只有当输入的内容可以转为整数时才不会触发异常，而代码也会按照正常流式顺序执行到break语句块处跳出循环。

输出结果：

```python
请输入一个0~100之间的数：[][]
输入内容必须为整数！
请输入一个0~100之间的数：50
遗憾，太大了！
请输入一个0~50之间的数：25
遗憾，太小了！
请输入一个25~50之间的数：37
遗憾，太小了！
请输入一个37~50之间的数：43
预测3次，你猜中了！
请按任意键继续. . .
```

## 函数和代码复用

### 1 函数的基本使用

#### 函数的定义

Python使用`def`保留字定义一个函数，语法形式如下：

```python
def <函数名>(<参数列表>):
    <函数体>
    return <返回值列表>
```

其中，函数名可以是任何有效的Python标识符；参数列表是调用该函数时传递给它的值，个数大于等于0个；当需要返回值时，使用保留字return和返回值列表，否则函数可以没有return语句

函数调用和执行的一般形式：

```python
<函数名>(<参数列表>)
```

#### 函数调用过程

1. 调用程序在调用处暂停执行
2. 在调用时将实参复制给函数的形参
3. 执行函数体语句
4. 函数调用结束给出返回值，程序回到调用前的暂停出继续执行

#### lambda函数

匿名函数，又称lambda函数，并非没有名字，而是将函数名作为函数结果返回

语法格式如下：

```python
<函数名> = lambda <参数列表>: <表达式>
```

lambda函数用于定义简单的、能够在一行内表示的函数，返回一个函数类型

### 2 函数的参数传递

#### 可选参数和可变数量参数

当函数被调用时，如果没有传入对应的参数值，则使用函数定义时的默认值替代

```python
def dup(str, times = 2):
    print(str*times)
dup("knock~")
dup("knock~",4)
```

输出结果：

```python
knock~knock~
knock~knock~knock~knock~
```

函数定义时，也可以设计可变数量参数，通过在参数前增加星号（*）实现。带有星号的可变参数只能出现在参数列表的最后。调用时，这些参数被当作元组类型传递到函数中

```python
def vfunc(a, *b):
    print(type(b))
    for n in b:
        a += n
    return a
print(vfunc(1,2,3,4,5))
```

输出结果：

```python
<class 'tuple'>
15
```

#### 参数的位置和名称传递

为解决可读性问题，Python提供了按照形参名称输入实参的方式，函数调用如下：

```
result = func(x2=4, y2=5, z2=6, x1=1, y1=2, z1=3)
```

#### 函数的返回值

> return语句用来退出函数并将程序返回到函数被调用的位置继续执行，且可以同时将0到多个函数运算后的结果返回给函数被调用处的变量，多个值以元组类型保存。函数可以没有return，此时函数并不返回值

```python
def func(a, b):
    return b,a
s = func("knock~",2)
print(s, type(s))
```

输出结果：

```python
(2, 'knock~') <class 'tuple'>
```

#### 函数对变量的作用

一个程序中的变量包括：全局变量和局部变量。全局变量指在函数之外定义的变量，一般没有缩进，在程序执行全过程有效。局部变量指在函数内部使用的变量，仅在函数内部有效，当函数退出时变量将不存在

```python
n = 1 # 全局变量n
def func(a, b):
    n = b # 这个n是在函数内存中新生成的局部变量，不是全局变量
    return a * b
s = func("knock~", 2)
print(s, n) # 测试n值是否改变
```

输出结果：

```python
knock~knock~ 1
```

函数内部使用了变量n，并且将变量参数b赋值给变量n，但n值没有改变，因为函数func()有自己的内存空间，它将`n = b`语句理解为生成一个局部变量n，并将参数b赋值给它，此时func()函数没有将n当作全局变量，所以函数退出后，局部变量n被释放，全局变量n的值没有改变。

若希望让func()函数将n当作全局变量，需要在变量n使用前显式声明该变量为全局变量。

```python
n = 1 
def func(a, b):
    global n
    n = b 
    return a * b
s = func("knock~", 2)
print(s, n)
```

输出结果：

```python
knock~knock~ 2
```

Python函数对变量的作用遵守如下原则：

1. 简单数据类型变量无论是否与全局变量重名，紧张函数内部创建和使用，函数退出后变量被释放，如有全局同名变量，其值保持不变
2. 简单数据类型变量在用global保留字声明后，作为全局变量使用，函数退出后改变里保留且值被函数改变
3. 对于组合数据类型的全局变量，如果在函数内部没有被真实创建的同名变量，则函数内部可以直接使用并修改全局变量的值
4. 如果函数内部真实创建了组合数据类型变量，无论是否有同名全局变量，函数仅对局部变量进行操作，函数退出后局部变量被释放，全局变量值不变

### 3 datetime库的使用

#### 概述

> datetime库可以从系统中获得时间，并以用户选择的格式输出

1. date：日期表示类，可以表示年月日等
2. time：时间表示类，可以表示小时，分钟，秒，毫秒等
3. datetime：日期和时间表示的类，覆盖上述二者功能
4. timedelta：与时间间隔有关的类
5. tzinfo：与时区有关的信息表示类

引用方式如下：

```
from datetime import datetime
```

#### 解析

> datetime类的使用方式是首先创建一个datetime对象，然后通过对象的方法和属性显示时间

创建datetime对象的三种方法：`datetime.now()`、`datetime.utcnow()`、`datetime.datetime()`

1. datetime.now()

作用：返回一个datetime类型，表示当前的日期和时间，精确到微秒

参数：无

调用函数：

```python
from datetime import datetime
today = datetime.now()
print(today)
```

1. datetime.utcnow()

作用：返回一个datetime类型，表示当前日期和时间的UTC（世界标准时间）表示，精确到微秒

参数：无

调用函数：

```python
from datetime import datetime
today = datetime.utcnow()
print(today)
```

1. datetime.datetime()

datetime.now()和datettime.utcnow()都返回一个datetime类型的对象，也可以直接使用datetime()构造一个日期和时间对象，使用方法如下：

```
datetime(year, month, day, hour = 0, minute = 0, second = 0, microsecond = 0)
```

作用：返回一个datetime类型，表示指定的日期和时间，精确到微秒

参数如下：

- year：指定的年份
- month：指定的月份
- day：指定的日期
- hour：指定的小时
- minute：指定的分钟数
- second：指定的秒数
- microsecond：指定的微秒数

其中，hour、minute、second、microsecond参数可以全部或部分省略，使用方式如下：

```python
from datetime import datetime
someday = datetime(2023,1,8,22,22)
print(someday)
print(someday.min, someday.max, someday.year, someday.month, someday.day, someday.hour, someday.minute)
```

输出结果：

```python
2023-01-08 22:22:00
0001-01-01 00:00:00 9999-12-31 23:59:59.999999 2023 1 8 22 22
```

这里的someday是一个对象，可以调用方法来返回对象的属性

常用的时间格式化方法

| 属性                     | 描述                                          |
| ------------------------ | --------------------------------------------- |
| someday.isoformat()      | 采用ISO 8601标准显示时间                      |
| someday.isoweekday()     | 根据日期计算星期后返回1~7，对应星期一到星期日 |
| someday.strftime(format) | 根据格式化字符串format进行格式显示的方法      |

```python
someday = datetime(2023,1,8,22,22,32,7)
print(someday)
print(someday.isoformat(), someday.isoweekday(), someday.strftime("%Y-%m-%d %H:%M:%S"))
```

strftime()方法的格式化控制符

| 格式化字符串 | 日期/时间     | 值范围和实例             |
| ------------ | ------------- | ------------------------ |
| %Y           | 年份          | 0001~9999，1900          |
| %m           | 月份          | 01~12，10                |
| %B           | 月名          | January~December，April  |
| %b           | 月名缩写      | Jan~Dec，Apr             |
| %d           | 日期          | 01~31，25                |
| %A           | 星期          | Monday~Sunday，Wednesday |
| %a           | 星期缩写      | Mon~Sun，Wed             |
| %H           | 小时（24h制） | 00~23，12                |
| %M           | 分钟          | 00~59，26                |
| %S           | 秒            | 00~59，26                |
| %x           | 日期          | 月/日/年，04/04/2023     |
| %X           | 时间          | 时:分:秒，19:09:31       |

strftime()格式化字符串的数字左侧会自动补0，也可以与print()的格式化函数一起使用

> datetime库主要用于对时间的表示，从格式化角度掌握strftime()函数已经能够处理很多情况。

## 组合数据类型

### 1 组合数据类型概述

#### 序列类型

> 序列类型是一维元素向量，元素之间存在先后关系，通过序号访问。

由于元素之间存在顺序关系，所以序列中可以存在数值相同但位置不同的元素，序列类型支撑成员关系操作符（in）、长度计算函数（len()）、分片（[]），元素本身也可以是序列类型

Python中的序列类型

1. 字符串
2. 元组：包含0个或多个数据项的不可变序列类型。元组生成后是固定的，其中任何数据都不能替换或删除。多用于表达固定数据项、**函数多返回值**、**多变量同步赋值**、**循环遍历**等情况。生成元组只需要使用逗号将元素隔离开即可，也可以增加圆括号，但圆括号在不混淆予以的情况下不是必须的。一个元组可以作为另一个元组的元素。
3. 列表：一个可以修改数据项的序列类型。

以上都可以使用相同的索引体系，即正向递增序号和反向递减序号

序列类型中12个通用的操作符和函数

| 操作符               | 描述                                                     |
| -------------------- | -------------------------------------------------------- |
| x in s               | 若x是s的元素，返回True，否则返回False                    |
| x not in s           | 若x不是s的元素，返回True，否则返回False                  |
| s + t                | 连接s和t                                                 |
| s * n 或 n * s       | 将序列s复制n次                                           |
| s[i]                 | 索引，返回序列的第i个元素                                |
| s[i: j]              | 分片，返回包含序列s第i到j个元素的子序列，不包含第j个元素 |
| s[i: j: k]           | 步骤分片，返回包含序列s第i到j个元素以k为步数的子序列     |
| len(s)               | 返回s的元素个数（长度）                                  |
| min(s)               | 序列s中的最小元素                                        |
| max(s)               | 序列s中的最大元素                                        |
| s.index(x[, i[, j]]) | 序列中从i开始到j位置第一次出现元素x的位置                |
| s.count(x)           | 序列s中出现x的总次数                                     |

#### 集合类型

> 包含0个或多个数据项的无序组合，集合中的元素不可重复，元素类型只能是固定数据类型，如基本数据类型与元组，而列表、字典和集合类型本身都是可变数据类型，不能作为集合的元素出现。

由于集合是无序组合，没有索引和位置的概念，不能分片，集合中的元素可以动态增加或删除。集合用大括号（{}）表示，可以用赋值语句生成一个集合。

```python
S = {425, "BIT", (10, "CS"), 424}
print(S)
T = {425, "BIT", (10, "CS"), 424, 425}
print(T)
```

输出结果：

```python
{424, 425, 'BIT', (10, 'CS')}
{424, 425, 'BIT', (10, 'CS')}
```

由于集合元素是无序的，集合的打印效果与定义顺序可以不一致，由于集合元素独一无二，使用集合类型能够过滤掉重复元素。

set(x)函数可以用于生成集合，输入的参数可以是任何组合数据类型，返回结果是一个无重复且排序任意的集合，举例如下：

```python
W = set("apple")
print(W)
V = set(("cat","dog","tiger","human"))
print(V)
```

输出结果：

```python
{'p', 'a', 'l', 'e'}
{'tiger', 'human', 'cat', 'dog'}
```

集合类型的操作函数或方法

| 操作函数或方法  | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| S.add(x)        | 若数据项x不在集合S中，将x增加到S                             |
| S.clear()       | 移除S中的所有数据项                                          |
| S.copy()        | 返回集合S的一个副本                                          |
| S.pop()         | 随即返回集合S中的一个元素，并将此元素从S中删除，若S为空，产生KeyError异常 |
| S.discard(x)    | 若x在集合S中，移除该元素，不在也不报错                       |
| S.remove(x)     | 若x在集合S中，移除该元素，不在则产生KeyError异常             |
| S.isdisjoint(T) | 若集合S与T没有相同元素，返回True                             |
| len(S)          | 返回集合S的元素个数                                          |
| x in S          | 若x是S的元素，返回True，否则返回False                        |
| x not in S      | 若x不是S的元素，返回True，否则返回False                      |

集合类型主要用于：**成员关系测试**、**元素去重**和**删除数据项**

#### 映射类型

> 映射类型是“键-值”数据项的组合，每个元素是一个键值对，即元素是(key, value)，元素之间是无序的。键值对是一种二元关系，源于属性和值的映射关系。映射类型主要以字典（dict）体现

### 2 列表类型和操作

#### 列表类型的概念

列表用中括号（[]）表示，也可以通过list()函数将元组或字符串转化成列表。直接使用list()函数会返回一个空列表。示例代码如下：

```python
ls = [425, "BIT", [10, "CS"], 424]
print(ls)
print(ls[2][-1][0])
print(list((425, "BIT", (10, "CS"), 424, 425)))
print(list("你好世界！"))
print(list())
```

输出结果：

```python
[425, 'BIT', [10, 'CS'], 424]
C
[425, 'BIT', (10, 'CS'), 424, 425]
['你', '好', '世', '界', '！']
[]
```

列表必须通过显示的数据赋值才能生成，简单将一个列表赋值给另一个列表不会生成新的列表对象。示例如下：

```python
ls = [425, "BIT", [10, "CS"], 424]
lt = ls # lt是ls所对应数据的引用，lt并不包含真实数据
ls[0] = 0
print(lt)
```

输出结果：

```python
[0, 'BIT', [10, 'CS'], 424]
```

ls由实际数据赋值产生，为列表对象。将ls赋值给lt仅能产生对列表ls的一个新的引用，此时，lt和ls变量都是实际数据的表示或引用，真实数据只存储一份，因此，修改ls同时也修改了lt。

#### 列表类型的操作

列表类型特有的函数或方法

| 函数或方法              | 描述                                            |
| ----------------------- | ----------------------------------------------- |
| ls[i] = x               | 替换列表ls第i数据项为x                          |
| ls[i: j] = lt           | 用列表lt替换列表ls中第i到第j项数据（不含第j项） |
| ls[i: j: k] = lt        | 用列表ls替换列表ls中第i到第j项以k为步数的数据   |
| del ls[i: j]            | 删除列表ls第i到第j项数据，等价于ls[i: j] = []   |
| del ls[i: j: k]         | 删除列表ls第i到第j项以k为步数数据               |
| ls+=lt 或 ls.extend(lt) | 将列表lt元素增加到列表ls中                      |
| ls *= n                 | 更新列表ls，其元素重复n次                       |
| ls.append(x)            | 在列表最后增加一个元素x                         |
| ls.clear()              | 删除ls中的所有元素                              |
| ls.copy()               | 生成一个新列表，复制ls中的所有元素              |
| ls.insert(i, x)         | 在列表ls的第i位置增加元素x                      |
| ls.pop(i)               | 将列表ls中的第i项元素取出并删除该元素           |
| ls.remove(x)            | 将列表ls中出现的第一个元素x删除                 |
| ls.reverse()            | 反转列表ls中的元素                              |

当使用一个列表改变另一个列表值时，Python不要求两个列表长度一样，但遵循“多增少减”的原则，示例程序如下：

```python
vlist = list(range(5))
print(vlist)
print(len(vlist[2:]))
print(2 in vlist)
vlist[3] = "python"
print(vlist)
vlist[1:3] = ["bit", "computer"]
print(vlist)
vlist[1:3] = ["new_bit","new_computer",123]
print(vlist)
vlist[1:3] = ["fewer"]
print(vlist)
```

输出结果：

```python
[0, 1, 2, 3, 4]
3
True
[0, 1, 2, 'python', 4]
[0, 'bit', 'computer', 'python', 4]
[0, 'new_bit', 'new_computer', 123, 'python', 4]
[0, 'fewer', 123, 'python', 4]
```

vlist[1: 3]子序列包含两个元素，对其赋值却给了3个元素，并不会报错，vlist的结果包含了赋值列表中的多于元素，同样，当使用包含更少元素赋值列表时，原列表元素会相应减少。

列表通过for-in语句对其元素进行遍历的语法格式如下：

```python
for <任意变量名> in <列表名>:
    <语句块>
```

### 3 字典类型和操作

> 字典是包含0个活多个键值对的集合，没有长度限制，可以根据键索引值的内容

#### 字典类型的概念

列表的索引模式：`<整数序号>`查找`<被索引内容>`

字典可以通过大括号（{}）建立，建立模式如下：

```python
{<键1>:<值1>,<键2>:<值2>, ... , <键n>:<值n>}
```

其中，键和值通过冒号连接，不同键值对通过逗号隔开。字典类型也具有和集合类似的性质，即键值对之间没有顺序且不能重复。

一般来说，字典中键值对的访问模式如下，采用中括号格式：

```
<值> = <字典变量>[<键>]
```

#### 字典类型的操作

```python
D_country = {"China":"Beijing","USA":"Washington","France":"Paris"}
print(D_country)
print(D_country["China"])
D_country["China"] = "BigBeijing"
print(D_country)
```

也可以直接使用大括号（{}）创建一个空的字典，并它通过中括号（[]）向其增加元素

```python
Dp = {}
Dp["2^10"] = 1024
print(Dp["2^10"])
```

字典类型的函数和方法

| 函数和方法               | 描述                                                   |
| ------------------------ | ------------------------------------------------------ |
| <d>.keys()               | 返回所有键信息                                         |
| <d>.values()             | 返回所有值信息                                         |
| <d>.items()              | 返回所有键值对                                         |
| <d>.get(<key>,<default>) | 键存在则返回相应值，否则返回默认值                     |
| <d>.pop(<key>,<default>) | 键存在则返回相应值，同时删除键值对，否则返回默认值     |
| <d>.popitem()            | 随机从字典中取出一个键值对，以元组(key, value)形式返回 |
| <d>.clear()              | 删除所有键值对                                         |
| del <d>[<key>]           | 删除字典中某一个键值对                                 |
| <key> in <d>             | 如果键在字典中则返回True，否则返回False                |

```python
D_country = {"China":"Beijing","USA":"Washington","France":"Paris"}
print(D_country)
print(D_country.keys())
print(list(D_country.values()))
print(D_country.items())
print("China" in D_country)
print(D_country.get("USA", "Sydney")) # 美国在字典中存在，则不返回悉尼
print(D_country.get("Australia", "Sydney")) # 澳大利亚在字典中不存在，故返回悉尼
```

输出结果：

```python
{'China': 'Beijing', 'USA': 'Washington', 'France': 'Paris'}
dict_keys(['China', 'USA', 'France'])
['Beijing', 'Washington', 'Paris']
dict_items([('China', 'Beijing'), ('USA', 'Washington'), ('France', 'Paris')])
True
Washington
Sydney
```

如果希望keys(), values()和items()方法返回列表类型，可以采用list()函数将返回值转换成列表

字典也可以通过`for-in`语句对其元素进行遍历，基本语法结构如下：

```python
for <变量名> in <字典名>:
	<语句块>
```

由于键值对中的键相当于索引，因此，for循环返回的变量名是字典的索引值。如果需要获得键对应的值，可以在语句块中通过get()方法获得。

```python
for key in D_country:
    print(key)
    print(D_country.get(key))
```

输出结果：

```python
China
Beijing
USA
Washington
France
Paris
```

字典的基本原则：

1. 字典是一个键值对的集合，该集合以键为索引，一个键信息只对应一个值信息
2. 字典中元素以键信息为索引访问
3. 字典长度是可变的，可以通过键信息赋值实现增加或修改键值对

### 4 jieba库的使用

#### jieba库概述

jieba库是Python中的第三方中文分词库

需要通过pip命令安装，命令如下：

```python
pip install jieba # 或 pip3 install jieba 
```

**分词原理**：利用一个中文词库，将带分词的内容与分词词库进行比对，通过图结构和动态规划方法找到最大概率词组。除此之外，jieba库还提供增加自定义中文单词的功能

支持3种分词模式：

1. 精确模式：将句子最精确地分开，适合文本分析；
2. 全模式：把句子种所有可以成词的词语都扫描出来，速度非常快，但是不能消除歧义；
3. 搜索引擎模式：在精确模式的基础上，对长词再次切分，提高召回率，适用于搜索引擎分词

#### jieba库解析

jieba库主要提供分词功能，可以辅助自定义分词词典。

jieba库常用的分词函数

| 函数                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| jieba.cut(s)                  | 精确模式，返回一个可迭代的数据类型                           |
| jieba.cut(s, cut_all = True)  | 全模式，输出文本s中所有可能的单词                            |
| jieba.cut_for_search(s)       | 搜索引擎模式，适合搜索引擎及案例索引的分词结果               |
| jieba.lcut(s)                 | 精确模式，返回一个列表类型，输出的分词能够完整且不多于地组成原始文本，建议使用 |
| jieba.lcut(s, cut_all = True) | 全模式，返回一个列表类型，输出原始文本中可能产生的所有问题，冗余性最大，建议使用 |
| jieba.lcut_for_search(s)      | 搜索引擎模式，返回一个列表类型，首先执行精确模式，然后再对其中的长词进一步切分获得结果，建议使用 |
| jieba.add_word(w)             | 像分词词典词典中增加新词w                                    |

## 文件和数据格式化

### 1 文件的使用

#### 文件概述

文件是一个存储在辅助存储器上的数据序列，可以包含任何数据内容

文本文件和二进制文件

```python
textFile = open("D:\\Download\\ProgrammingTools\\VSCode\\CodeWorkSpace\\Python-study\\Code\\Unit7\\7.1.txt","rt",encoding='utf-8') # 只读文本文件模式
print(textFile.readline())
textFile.close()


textFile = open("D:\\Download\\ProgrammingTools\\VSCode\\CodeWorkSpace\\Python-study\\Code\\Unit7\\7.1.txt","rb") # 只读二进制文件模式
print(textFile.readline())
textFile.close()
```

输出结果：

```python
鸡你太美！噢，baby!
b'\xe9\xb8\xa1\xe4\xbd\xa0\xe5\xa4\xaa\xe7\xbe\x8e\xef\xbc\x81\xe5\x99\xa2\xef\xbc\x8cbaby!'
```

采用文本方式读入文件，文件经过编码形成字符串，打印出有含义的字符；采用二进制方式打开文件，文件被解析为字节流。由于存在编码，字符串中的一个字符由两个字节表示。

#### 文件的打开关闭

Python对文本文件和二进制文件采用统一的操作步骤：“打开——操作——关闭”

Python通过解释器内置的open()函数打开一个文件，open()函数格式如下：

```
<变量名> = open(<文件名>, <打开模式>)
```

其中，文件名可以是文件的实际名字，也可以是包含完整路径的名字。

open()函数提供的7种基本的打开模式

| 文件的打开模式 | 含义                                                   |
| -------------- | ------------------------------------------------------ |
| 'r'            | 只读模式，若文件不存在，则返回异常                     |
| 'w'            | 覆盖写模式，文件不存在则创建，存在则完全覆盖           |
| 'x'            | 创建写模式，文件不存在则创建，存在则返回异常           |
| 'a'            | 追加写模式，文件不存在则创建，存在则在文件最后追加内容 |
| 'b'            | 二进制文件模式                                         |
| 't'            | 文本文件模式                                           |
| '+'            | 与r/w/x/a一同使用，在原功能的基础上增加同时读写功能    |

打开模式使用字符串方式表示，根据字符串定义，单引号或者双引号均可。上述打开模式中，'r'、'w'、'x'、'a'可以和'b'、't'、'+'组合使用，形成既表达读写又表达文件模式的方式。

open()函数默认采用'rt'（文本只读）模式：

```python
textfile = open('7.1.txt','r')
或
textfile = open('7.1.txt')
```

读取一个二进制文件，如图片、视频或音乐，需要使用'rb'来打开，例如：

```
binfile = open('music.mp3','rb')
```

文件使用结束后，用close()方法关闭，使用方式如下：

```
<变量名>.close()
```

#### 文件的读写

文件内容读取方法：

| 操作方法                  | 含义                                                         |
| ------------------------- | ------------------------------------------------------------ |
| <file>.readall()          | 读入整个文件内容，返回一个字符串或字节流（文本方式：字符串；二进制方式：字节流） |
| <file>.read(size=-1)      | 从文件中读入整个文件内容，如果给出参数，读入前size长度的字符串或字节流 |
| <file>.readline(size=-1)  | 从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流 |
| <file>.readlines(hint=-1) | 从文件中读入所有行，以每行为元素形成一个列表，如果给出参数，读入hint行 |

文件内容写入的方法：

| 方法                     | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| <file>.write(s)          | 向文件写入一个字符串或字节流                                 |
| <file>.writelines(lines) | 将一个元素全为字符串的列表写入文件，但并不在列表后面增加换行，只是将列表内容直接排列输出 |
| <file>.seek(offset)      | 改变当前文件操作指针的位置，offset：0——文件开头；1——当前位置；2——文件结尾 |
